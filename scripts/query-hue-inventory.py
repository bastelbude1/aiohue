#!/usr/bin/env python3
"""
Philips Hue Inventory Query Script

This script queries the inventory data collected from Philips Hue bridges
and provides flexible filtering and output options.

Usage:
    # Find all lights with "Küche" in name
    python3 query-hue-inventory.py --type lights --name "*Küche*"

    # All devices on specific bridge
    python3 query-hue-inventory.py --bridge abc123def456 --type devices

    # Lights that are currently on
    python3 query-hue-inventory.py --type lights --state on

    # Summary across all bridges
    python3 query-hue-inventory.py --summary

    # Detailed scene information
    python3 query-hue-inventory.py --type scenes --name "Evening" --detailed

    # JSON output for scripting
    python3 query-hue-inventory.py --type lights --json

Requirements:
    - Inventory files in bridges/inventory/ directory
    - Generated by inventory-hue-bridge.py

Output:
    - Default: Interactive table with key information
    - JSON mode: Machine-readable JSON output
    - Detailed mode: Full attribute display
    - Summary mode: Count statistics

Exit Codes:
    0 - Success (results found)
    1 - Error or no results found
"""

import sys
import os
from pathlib import Path

# Auto-activate virtual environment
VENV_PATH = Path(__file__).parent.parent.parent / "venv"

if VENV_PATH.exists():
    venv_site_packages = VENV_PATH / "lib" / f"python{sys.version_info.major}.{sys.version_info.minor}" / "site-packages"
    if venv_site_packages.exists():
        sys.path.insert(0, str(venv_site_packages))

import argparse
import json
import fnmatch
import re
from typing import Dict, List, Optional, Any

# Default paths
DEFAULT_INVENTORY_DIR = Path(__file__).parent.parent / "bridges" / "inventory"


def parse_arguments():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Query Philips Hue bridge inventory data",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --type lights --name "*Küche*"         # Find lights with "Küche" in name
  %(prog)s --bridge abc123def456                  # Query specific bridge
  %(prog)s --type lights --state on               # Find lights that are on
  %(prog)s --type devices --detailed              # Detailed device information
  %(prog)s --summary                              # Summary across all bridges
  %(prog)s --type scenes --json                   # JSON output for scripting

State Filters:
  --state on                    # Lights that are on
  --state off                   # Lights that are off
  --state "brightness>50"       # Lights with brightness > 50%
  --state "brightness<30"       # Lights with brightness < 30%

For more information, visit: https://github.com/home-assistant-libs/aiohue
        """
    )

    parser.add_argument(
        "--inventory-dir",
        metavar="DIR",
        type=str,
        default=str(DEFAULT_INVENTORY_DIR),
        help=f"Inventory directory (default: {DEFAULT_INVENTORY_DIR})"
    )

    parser.add_argument(
        "--bridge",
        metavar="BRIDGE_ID",
        type=str,
        help="Query specific bridge by ID (default: all bridges)"
    )

    parser.add_argument(
        "--name",
        metavar="PATTERN",
        type=str,
        help="Filter by name pattern (supports wildcards: *, ?)"
    )

    parser.add_argument(
        "--type",
        metavar="TYPE",
        type=str,
        choices=["lights", "devices", "scenes", "sensors", "zones", "rooms"],
        help="Filter by resource type"
    )

    parser.add_argument(
        "--state",
        metavar="STATE",
        type=str,
        help="Filter by state (on, off, brightness>N, brightness<N)"
    )

    # Output format options
    output_group = parser.add_mutually_exclusive_group()

    output_group.add_argument(
        "--json",
        action="store_true",
        help="Output in JSON format (machine-readable)"
    )

    output_group.add_argument(
        "--detailed",
        action="store_true",
        help="Show detailed information for each item"
    )

    output_group.add_argument(
        "--summary",
        action="store_true",
        help="Show summary counts only"
    )

    parser.add_argument(
        "--version",
        action="version",
        version="%(prog)s 1.0.0"
    )

    return parser.parse_args()


def load_inventories(inventory_dir: str, bridge_filter: Optional[str] = None) -> Dict[str, Dict]:
    """
    Load inventory files from directory.

    Args:
        inventory_dir (str): Path to inventory directory
        bridge_filter (str, optional): Bridge ID to filter (None = all bridges)

    Returns:
        dict: Mapping of bridge_id to inventory data
    """
    inventories = {}
    inventory_path = Path(inventory_dir)

    if not inventory_path.exists():
        print(f"Error: Inventory directory not found: {inventory_dir}", file=sys.stderr)
        return inventories

    try:
        for file_path in inventory_path.glob("*.json"):
            # Extract bridge_id from filename (format: {name}-{bridge_id}.json)
            filename = file_path.stem
            parts = filename.rsplit('-', 1)

            if len(parts) == 2:
                bridge_id = parts[1]
            else:
                # Fallback: assume entire filename is bridge_id
                bridge_id = filename

            # Apply bridge filter if specified
            if bridge_filter and bridge_id != bridge_filter:
                continue

            with open(file_path, 'r') as f:
                inventory = json.load(f)
                inventories[bridge_id] = inventory

    except Exception as e:
        print(f"Error loading inventories: {e}", file=sys.stderr)

    return inventories


def filter_by_name(items: List[Dict], pattern: str) -> List[Dict]:
    """
    Filter items by name pattern (supports wildcards).

    Args:
        items (list): List of items to filter
        pattern (str): Name pattern (wildcards: *, ?)

    Returns:
        list: Filtered items
    """
    filtered = []
    for item in items:
        metadata = item.get('metadata', {})
        name = metadata.get('name', '') if metadata else ''

        if fnmatch.fnmatch(name.lower(), pattern.lower()):
            filtered.append(item)

    return filtered


def filter_by_state(items: List[Dict], state_filter: str) -> List[Dict]:
    """
    Filter lights by state.

    Args:
        items (list): List of light items
        state_filter (str): State filter (on, off, brightness>N, brightness<N)

    Returns:
        list: Filtered lights
    """
    filtered = []

    # Parse state filter
    if state_filter.lower() == 'on':
        for item in items:
            on_state = item.get('on', {})
            if on_state and on_state.get('on') is True:
                filtered.append(item)

    elif state_filter.lower() == 'off':
        for item in items:
            on_state = item.get('on', {})
            if on_state and on_state.get('on') is False:
                filtered.append(item)

    elif 'brightness' in state_filter.lower():
        # Parse brightness filter (e.g., "brightness>50" or "brightness<30")
        match = re.match(r'brightness\s*([<>]=?)\s*(\d+)', state_filter, re.IGNORECASE)
        if match:
            operator = match.group(1)
            threshold = float(match.group(2))

            for item in items:
                dimming = item.get('dimming', {})
                if dimming:
                    brightness = dimming.get('brightness', 0)

                    if operator == '>' and brightness > threshold:
                        filtered.append(item)
                    elif operator == '>=' and brightness >= threshold:
                        filtered.append(item)
                    elif operator == '<' and brightness < threshold:
                        filtered.append(item)
                    elif operator == '<=' and brightness <= threshold:
                        filtered.append(item)

    return filtered


def query_resources(inventories: Dict, args) -> Dict[str, List]:
    """
    Query resources from inventories based on filters.

    Args:
        inventories (dict): Bridge inventories
        args: Parsed command-line arguments

    Returns:
        dict: Results organized by bridge_id and resource type
    """
    results = {}

    for bridge_id, inventory in inventories.items():
        bridge_name = inventory.get('bridge_info', {}).get('config', {}).get('name', bridge_id)
        resources = inventory.get('resources', {})

        bridge_results = {
            'bridge_id': bridge_id,
            'bridge_name': bridge_name,
            'resources': {}
        }

        # Determine which resource types to query
        if args.type:
            resource_types = [args.type]
        else:
            # Query all resource types
            resource_types = ['lights', 'devices', 'scenes', 'sensors']

        for resource_type in resource_types:
            items = []

            # Handle zones/rooms (nested in groups)
            if resource_type == 'zones':
                groups = resources.get('groups', {})
                items = groups.get('zones', {}).get('items', [])
            elif resource_type == 'rooms':
                groups = resources.get('groups', {})
                items = groups.get('rooms', {}).get('items', [])
            else:
                resource_data = resources.get(resource_type, {})
                items = resource_data.get('items', [])

            # Apply name filter
            if args.name and items:
                items = filter_by_name(items, args.name)

            # Apply state filter (only for lights)
            if args.state and resource_type == 'lights' and items:
                items = filter_by_state(items, args.state)

            if items:
                bridge_results['resources'][resource_type] = items

        # Only include bridge if it has matching results
        if bridge_results['resources']:
            results[bridge_id] = bridge_results

    return results


def format_table(results: Dict) -> str:
    """
    Format results as interactive table.

    Args:
        results (dict): Query results

    Returns:
        str: Formatted table
    """
    if not results:
        return "No matching resources found."

    output = []
    output.append("=" * 80)
    output.append("Query Results")
    output.append("=" * 80)
    output.append("")

    for bridge_id, bridge_data in results.items():
        bridge_name = bridge_data['bridge_name']
        output.append(f"Bridge: {bridge_name} ({bridge_id})")
        output.append("-" * 80)

        for resource_type, items in bridge_data['resources'].items():
            output.append(f"\n{resource_type.upper()} ({len(items)}):")

            for item in items:
                item_id = item.get('id', 'N/A')
                metadata = item.get('metadata', {})
                name = metadata.get('name', 'Unnamed') if metadata else 'Unnamed'
                item_type = item.get('type', 'Unknown')

                # Format based on resource type
                if resource_type == 'lights':
                    on_state = item.get('on', {})
                    is_on = on_state.get('on') if on_state else None
                    dimming = item.get('dimming', {})
                    brightness = dimming.get('brightness') if dimming else None

                    state_str = "ON" if is_on else "OFF" if is_on is False else "Unknown"
                    bright_str = f", {brightness:.0f}%" if brightness is not None else ""

                    output.append(f"  • {name} [{state_str}{bright_str}] - {item_id[:8]}...")

                elif resource_type == 'devices':
                    product_data = item.get('product_data', {})
                    product_name = product_data.get('product_name', 'Unknown') if product_data else 'Unknown'
                    output.append(f"  • {name} ({product_name}) - {item_id[:8]}...")

                elif resource_type == 'scenes':
                    output.append(f"  • {name} - {item_id[:8]}...")

                else:
                    output.append(f"  • {name} ({item_type}) - {item_id[:8]}...")

        output.append("")

    return "\n".join(output)


def format_detailed(results: Dict) -> str:
    """
    Format results with detailed information.

    Args:
        results (dict): Query results

    Returns:
        str: Detailed formatted output
    """
    if not results:
        return "No matching resources found."

    output = []
    output.append("=" * 80)
    output.append("Detailed Query Results")
    output.append("=" * 80)
    output.append("")

    for bridge_id, bridge_data in results.items():
        bridge_name = bridge_data['bridge_name']
        output.append(f"Bridge: {bridge_name} ({bridge_id})")
        output.append("-" * 80)

        for resource_type, items in bridge_data['resources'].items():
            output.append(f"\n{resource_type.upper()}:")

            for idx, item in enumerate(items, 1):
                metadata = item.get('metadata', {})
                name = metadata.get('name', 'Unnamed') if metadata else 'Unnamed'

                output.append(f"\n  [{idx}] {name}")
                output.append(f"      ID: {item.get('id', 'N/A')}")
                output.append(f"      Type: {item.get('type', 'Unknown')}")

                # Show type-specific details
                if resource_type == 'lights':
                    on_state = item.get('on', {})
                    if on_state:
                        output.append(f"      State: {'ON' if on_state.get('on') else 'OFF'}")

                    dimming = item.get('dimming', {})
                    if dimming and dimming.get('brightness') is not None:
                        output.append(f"      Brightness: {dimming.get('brightness'):.1f}%")

                    color_temp = item.get('color_temperature', {})
                    if color_temp and color_temp.get('mirek') is not None:
                        output.append(f"      Color Temp: {color_temp.get('mirek')} mirek")

                    color = item.get('color', {})
                    if color:
                        output.append(f"      Color: {color}")

                elif resource_type == 'devices':
                    product_data = item.get('product_data', {})
                    if product_data:
                        output.append(f"      Product: {product_data.get('product_name', 'Unknown')}")
                        output.append(f"      Manufacturer: {product_data.get('manufacturer_name', 'Unknown')}")
                        output.append(f"      Model: {product_data.get('model_id', 'Unknown')}")
                        output.append(f"      SW Version: {product_data.get('software_version', 'Unknown')}")

                elif resource_type == 'scenes':
                    group = item.get('group')
                    if group:
                        output.append(f"      Group: {group}")
                    actions = item.get('actions', [])
                    if actions:
                        output.append(f"      Actions: {len(actions)} configured")

                if metadata and 'archetype' in metadata:
                    output.append(f"      Archetype: {metadata.get('archetype')}")

        output.append("")

    return "\n".join(output)


def format_summary(results: Dict) -> str:
    """
    Format results as summary counts.

    Args:
        results (dict): Query results

    Returns:
        str: Summary output
    """
    if not results:
        return "No matching resources found."

    output = []
    output.append("=" * 70)
    output.append("Query Summary")
    output.append("=" * 70)
    output.append("")

    total_counts = {}

    for bridge_id, bridge_data in results.items():
        bridge_name = bridge_data['bridge_name']
        output.append(f"Bridge: {bridge_name} ({bridge_id})")

        for resource_type, items in bridge_data['resources'].items():
            count = len(items)
            output.append(f"  {resource_type.capitalize()}: {count}")

            total_counts[resource_type] = total_counts.get(resource_type, 0) + count

        output.append("")

    if len(results) > 1:
        output.append("-" * 70)
        output.append("Total Across All Bridges:")
        for resource_type, count in total_counts.items():
            output.append(f"  {resource_type.capitalize()}: {count}")
        output.append("")

    return "\n".join(output)


def main():
    """Main entry point for the script."""
    args = parse_arguments()

    # Load inventories
    inventories = load_inventories(args.inventory_dir, args.bridge)

    if not inventories:
        print("No inventory data found.", file=sys.stderr)
        if args.bridge:
            print(f"Bridge '{args.bridge}' not found in inventory.", file=sys.stderr)
        sys.exit(1)

    # Query resources
    results = query_resources(inventories, args)

    # Output results
    if args.json:
        # JSON output mode
        print(json.dumps(results, indent=2))
    elif args.summary:
        # Summary mode
        print(format_summary(results))
    elif args.detailed:
        # Detailed mode
        print(format_detailed(results))
    else:
        # Default interactive table mode
        print(format_table(results))

    # Exit with appropriate code
    sys.exit(0 if results else 1)


if __name__ == "__main__":
    main()
