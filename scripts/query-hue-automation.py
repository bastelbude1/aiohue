#!/usr/bin/env python3
"""
Philips Hue Automation Query Script

This script queries the automation data collected from Philips Hue bridges
and provides flexible filtering and output options.

Usage:
    # Find all smart scenes
    python3 query-hue-automation.py --type smart_scenes

    # Find enabled behavior instances
    python3 query-hue-automation.py --type behavior_instances --state enabled

    # Find automations by name
    python3 query-hue-automation.py --name "*Wake*"

    # Summary across all bridges
    python3 query-hue-automation.py --summary

    # Detailed automation information
    python3 query-hue-automation.py --type behavior_instances --detailed

    # JSON output for scripting
    python3 query-hue-automation.py --type smart_scenes --json

Requirements:
    - Automation files in bridges/automations/ directory
    - Generated by automation-hue-bridge.py

Output:
    - Default: Interactive table with key information
    - JSON mode: Machine-readable JSON output
    - Detailed mode: Full attribute display
    - Summary mode: Count statistics

Exit Codes:
    0 - Success (results found)
    1 - Error or no results found
"""

import sys
import os
from pathlib import Path

# Auto-activate virtual environment
VENV_PATH = Path(__file__).parent.parent.parent / "venv"

if VENV_PATH.exists():
    venv_site_packages = VENV_PATH / "lib" / f"python{sys.version_info.major}.{sys.version_info.minor}" / "site-packages"
    if venv_site_packages.exists():
        sys.path.insert(0, str(venv_site_packages))

import argparse
import json
import fnmatch
from typing import Dict, List, Optional, Any

# Default paths
DEFAULT_AUTOMATIONS_DIR = Path(__file__).parent.parent / "bridges" / "automations"


def parse_arguments():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Query Philips Hue bridge automation data",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --type smart_scenes                    # List all smart scenes
  %(prog)s --type behavior_instances --state enabled  # Find enabled automations
  %(prog)s --name "*Wake*"                        # Find automations by name
  %(prog)s --bridge ecb5faa015bb                  # Query specific bridge
  %(prog)s --type behavior_instances --detailed   # Detailed automation info
  %(prog)s --summary                              # Summary across all bridges
  %(prog)s --json                                 # JSON output for scripting

Automation Types:
  smart_scenes          # Time-based scheduled automations
  behavior_instances    # Active running automations
  behavior_scripts      # Available automation templates
  geofence_clients      # Location-based triggers
  geolocation           # Sun position data

State Filters (for behavior_instances):
  --state enabled       # Only enabled automations
  --state disabled      # Only disabled automations
  --state running       # Only running automations
  --state errored       # Only errored automations

For more information, visit: https://github.com/home-assistant-libs/aiohue
        """
    )

    parser.add_argument(
        "--automations-dir",
        metavar="DIR",
        type=str,
        default=str(DEFAULT_AUTOMATIONS_DIR),
        help=f"Automations directory (default: {DEFAULT_AUTOMATIONS_DIR})"
    )

    parser.add_argument(
        "--bridge",
        metavar="BRIDGE_ID",
        type=str,
        help="Query specific bridge by ID (default: all bridges)"
    )

    parser.add_argument(
        "--name",
        metavar="PATTERN",
        type=str,
        help="Filter by name pattern (supports wildcards: *, ?)"
    )

    parser.add_argument(
        "--type",
        metavar="TYPE",
        type=str,
        choices=["smart_scenes", "behavior_instances", "behavior_scripts", "geofence_clients", "geolocation"],
        help="Filter by automation type"
    )

    parser.add_argument(
        "--state",
        metavar="STATE",
        type=str,
        choices=["enabled", "disabled", "running", "errored"],
        help="Filter by state (for behavior_instances)"
    )

    # Output format options
    output_group = parser.add_mutually_exclusive_group()

    output_group.add_argument(
        "--json",
        action="store_true",
        help="Output in JSON format (machine-readable)"
    )

    output_group.add_argument(
        "--detailed",
        action="store_true",
        help="Show detailed information for each item"
    )

    output_group.add_argument(
        "--summary",
        action="store_true",
        help="Show summary counts only"
    )

    parser.add_argument(
        "--version",
        action="version",
        version="%(prog)s 1.0.0"
    )

    return parser.parse_args()


def load_automations(automations_dir: str, bridge_filter: Optional[str] = None) -> Dict[str, Dict]:
    """
    Load automation files from directory.

    Args:
        automations_dir (str): Path to automations directory
        bridge_filter (str, optional): Bridge ID to filter (None = all bridges)

    Returns:
        dict: Mapping of bridge_id to automation data
    """
    automations = {}
    automations_path = Path(automations_dir)

    if not automations_path.exists():
        print(f"Error: Automations directory not found: {automations_dir}", file=sys.stderr)
        return automations

    try:
        for file_path in automations_path.glob("*-automations.json"):
            # Extract bridge_id from filename (format: {name}-{bridge_id}-automations.json)
            filename = file_path.stem  # Remove .json
            parts = filename.rsplit('-automations', 1)[0]  # Remove -automations suffix
            parts = parts.rsplit('-', 1)  # Split name and bridge_id

            if len(parts) == 2:
                bridge_id = parts[1]
            else:
                # Fallback
                continue

            # Apply bridge filter if specified
            if bridge_filter and bridge_id != bridge_filter:
                continue

            with open(file_path, 'r') as f:
                automation_data = json.load(f)
                automations[bridge_id] = automation_data

    except Exception as e:
        print(f"Error loading automations: {e}", file=sys.stderr)

    return automations


def filter_by_name(items: List[Dict], pattern: str) -> List[Dict]:
    """
    Filter items by name pattern (supports wildcards).

    Args:
        items (list): List of items to filter
        pattern (str): Name pattern (wildcards: *, ?)

    Returns:
        list: Filtered items
    """
    filtered = []
    for item in items:
        metadata = item.get('metadata', {})
        name = metadata.get('name', '') if metadata else ''

        if fnmatch.fnmatch(name.lower(), pattern.lower()):
            filtered.append(item)

    return filtered


def filter_by_state(items: List[Dict], state_filter: str) -> List[Dict]:
    """
    Filter behavior instances by state.

    Args:
        items (list): List of behavior instance items
        state_filter (str): State filter (enabled, disabled, running, errored)

    Returns:
        list: Filtered behavior instances
    """
    filtered = []

    if state_filter.lower() == 'enabled':
        for item in items:
            if item.get('enabled') is True:
                filtered.append(item)

    elif state_filter.lower() == 'disabled':
        for item in items:
            if item.get('enabled') is False:
                filtered.append(item)

    elif state_filter.lower() == 'running':
        for item in items:
            status = item.get('status', '').lower()
            if status == 'running':
                filtered.append(item)

    elif state_filter.lower() == 'errored':
        for item in items:
            status = item.get('status', '').lower()
            if status == 'errored' or item.get('last_error'):
                filtered.append(item)

    return filtered


def query_automations(automations_data: Dict, args) -> Dict[str, List]:
    """
    Query automations from automation data based on filters.

    Args:
        automations_data (dict): Bridge automation data
        args: Parsed command-line arguments

    Returns:
        dict: Results organized by bridge_id and automation type
    """
    results = {}

    for bridge_id, automation_data in automations_data.items():
        bridge_name = automation_data.get('bridge_info', {}).get('config', {}).get('name', bridge_id)
        automations = automation_data.get('automations', {})

        bridge_results = {
            'bridge_id': bridge_id,
            'bridge_name': bridge_name,
            'automations': {}
        }

        # Determine which automation types to query
        if args.type:
            automation_types = [args.type]
        else:
            # Query all automation types
            automation_types = ['smart_scenes', 'behavior_instances', 'behavior_scripts']

        for automation_type in automation_types:
            items = []

            # Handle special case for geolocation (not a list)
            if automation_type == 'geolocation':
                geolocation = automations.get('geolocation')
                if geolocation and isinstance(geolocation, dict) and 'error' not in geolocation:
                    items = [geolocation]
            else:
                # Regular automation types
                automation_resource = automations.get(automation_type, {})
                if isinstance(automation_resource, dict) and 'items' in automation_resource:
                    items = automation_resource.get('items', [])

            # Apply name filter
            if args.name and items and automation_type != 'geolocation':
                items = filter_by_name(items, args.name)

            # Apply state filter (only for behavior_instances)
            if args.state and automation_type == 'behavior_instances' and items:
                items = filter_by_state(items, args.state)

            if items:
                bridge_results['automations'][automation_type] = items

        # Only include bridge if it has matching results
        if bridge_results['automations']:
            results[bridge_id] = bridge_results

    return results


def format_table(results: Dict) -> str:
    """
    Format results as interactive table.

    Args:
        results (dict): Query results

    Returns:
        str: Formatted table
    """
    if not results:
        return "No matching automations found."

    output = []
    output.append("=" * 80)
    output.append("Query Results")
    output.append("=" * 80)
    output.append("")

    for bridge_id, bridge_data in results.items():
        bridge_name = bridge_data['bridge_name']
        output.append(f"Bridge: {bridge_name} ({bridge_id})")
        output.append("-" * 80)

        for automation_type, items in bridge_data['automations'].items():
            output.append(f"\n{automation_type.upper().replace('_', ' ')} ({len(items)}):")

            if automation_type == 'smart_scenes':
                for item in items:
                    metadata = item.get('metadata', {})
                    name = metadata.get('name', 'Unnamed') if metadata else 'Unnamed'
                    state = item.get('state', 'Unknown')
                    item_id = item.get('id', 'N/A')
                    output.append(f"  • {name} [State: {state}] - {item_id[:8]}...")

            elif automation_type == 'behavior_instances':
                for item in items:
                    metadata = item.get('metadata', {})
                    name = metadata.get('name', 'Unnamed') if metadata else 'Unnamed'
                    enabled = item.get('enabled', False)
                    status = item.get('status', 'Unknown')
                    item_id = item.get('id', 'N/A')

                    enabled_str = "✓" if enabled else "✗"
                    output.append(f"  {enabled_str} {name} [{status}] - {item_id[:8]}...")

            elif automation_type == 'behavior_scripts':
                for item in items:
                    metadata = item.get('metadata', {})
                    name = metadata.get('name', 'Unnamed') if metadata else 'Unnamed'
                    description = item.get('description', '')
                    item_id = item.get('id', 'N/A')

                    desc_short = (description[:50] + '...') if len(description) > 50 else description
                    output.append(f"  • {name} - {desc_short} - {item_id[:8]}...")

            elif automation_type == 'geofence_clients':
                for item in items:
                    name = item.get('name', 'Unnamed')
                    item_id = item.get('id', 'N/A')
                    output.append(f"  • {name} - {item_id[:8]}...")

            elif automation_type == 'geolocation':
                for item in items:
                    is_configured = item.get('is_configured', False)
                    sun_today = item.get('sun_today', {})
                    sunset = sun_today.get('sunset_time', {}).get('time', 'N/A') if sun_today else 'N/A'
                    output.append(f"  • Configured: {is_configured}, Sunset: {sunset}")

        output.append("")

    return "\n".join(output)


def format_detailed(results: Dict) -> str:
    """
    Format results with detailed information.

    Args:
        results (dict): Query results

    Returns:
        str: Detailed formatted output
    """
    if not results:
        return "No matching automations found."

    output = []
    output.append("=" * 80)
    output.append("Detailed Query Results")
    output.append("=" * 80)
    output.append("")

    for bridge_id, bridge_data in results.items():
        bridge_name = bridge_data['bridge_name']
        output.append(f"Bridge: {bridge_name} ({bridge_id})")
        output.append("-" * 80)

        for automation_type, items in bridge_data['automations'].items():
            output.append(f"\n{automation_type.upper().replace('_', ' ')}:")

            for idx, item in enumerate(items, 1):
                if automation_type == 'geolocation':
                    output.append(f"\n  Geolocation Data:")
                    output.append(f"      Configured: {item.get('is_configured', False)}")
                    if 'sun_today' in item:
                        sun = item['sun_today']
                        output.append(f"      Sunset: {sun.get('sunset_time', {}).get('time', 'N/A')}")
                        output.append(f"      Sunrise: {sun.get('sunrise_time', {}).get('time', 'N/A')}")
                        output.append(f"      Day Type: {sun.get('day_type', 'N/A')}")
                    continue

                metadata = item.get('metadata', {})
                name = metadata.get('name', 'Unnamed') if metadata else 'Unnamed'

                output.append(f"\n  [{idx}] {name}")
                output.append(f"      ID: {item.get('id', 'N/A')}")
                output.append(f"      Type: {item.get('type', 'Unknown')}")

                # Show type-specific details
                if automation_type == 'smart_scenes':
                    output.append(f"      State: {item.get('state', 'Unknown')}")
                    group = item.get('group')
                    if group:
                        output.append(f"      Group: {group}")
                    if 'transition_duration' in item:
                        output.append(f"      Transition: {item.get('transition_duration')}ms")
                    if 'week_timeslots' in item and item['week_timeslots']:
                        output.append(f"      Timeslots: {len(item['week_timeslots'])} configured")

                elif automation_type == 'behavior_instances':
                    output.append(f"      Enabled: {item.get('enabled', False)}")
                    output.append(f"      Status: {item.get('status', 'Unknown')}")
                    script_id = item.get('script_id')
                    if script_id:
                        output.append(f"      Script ID: {script_id}")
                    last_error = item.get('last_error')
                    if last_error:
                        output.append(f"      Last Error: {last_error}")
                    if 'configuration' in item and item['configuration']:
                        output.append(f"      Configuration: {json.dumps(item['configuration'], indent=10)[:100]}...")

                elif automation_type == 'behavior_scripts':
                    description = item.get('description', '')
                    if description:
                        output.append(f"      Description: {description}")
                    version = item.get('version')
                    if version:
                        output.append(f"      Version: {version}")
                    max_instances = item.get('max_number_instances')
                    if max_instances:
                        output.append(f"      Max Instances: {max_instances}")

                elif automation_type == 'geofence_clients':
                    output.append(f"      Name: {item.get('name', 'Unnamed')}")

        output.append("")

    return "\n".join(output)


def format_summary(results: Dict) -> str:
    """
    Format results as summary counts.

    Args:
        results (dict): Query results

    Returns:
        str: Summary output
    """
    if not results:
        return "No matching automations found."

    output = []
    output.append("=" * 70)
    output.append("Query Summary")
    output.append("=" * 70)
    output.append("")

    total_counts = {}

    for bridge_id, bridge_data in results.items():
        bridge_name = bridge_data['bridge_name']
        output.append(f"Bridge: {bridge_name} ({bridge_id})")

        for automation_type, items in bridge_data['automations'].items():
            count = len(items)
            display_name = automation_type.replace('_', ' ').title()

            # Add state counts for behavior instances
            if automation_type == 'behavior_instances':
                enabled_count = sum(1 for item in items if item.get('enabled'))
                output.append(f"  {display_name}: {count} ({enabled_count} enabled)")
            else:
                output.append(f"  {display_name}: {count}")

            total_counts[automation_type] = total_counts.get(automation_type, 0) + count

        output.append("")

    if len(results) > 1:
        output.append("-" * 70)
        output.append("Total Across All Bridges:")
        for automation_type, count in total_counts.items():
            display_name = automation_type.replace('_', ' ').title()
            output.append(f"  {display_name}: {count}")
        output.append("")

    return "\n".join(output)


def main():
    """Main entry point for the script."""
    args = parse_arguments()

    # Load automations
    automations_data = load_automations(args.automations_dir, args.bridge)

    if not automations_data:
        print("No automation data found.", file=sys.stderr)
        if args.bridge:
            print(f"Bridge '{args.bridge}' not found in automations.", file=sys.stderr)
        sys.exit(1)

    # Query automations
    results = query_automations(automations_data, args)

    # Output results
    if args.json:
        # JSON output mode
        print(json.dumps(results, indent=2))
    elif args.summary:
        # Summary mode
        print(format_summary(results))
    elif args.detailed:
        # Detailed mode
        print(format_detailed(results))
    else:
        # Default interactive table mode
        print(format_table(results))

    # Exit with appropriate code
    sys.exit(0 if results else 1)


if __name__ == "__main__":
    main()
